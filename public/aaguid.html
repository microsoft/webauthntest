<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AAGUID Inspector</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; padding: 18px; }
    .box { max-width: 820px; margin: 0 auto; }
    pre { background:#f6f8fa; padding:12px; border-radius:6px; overflow:auto; }
  </style>
</head>
<body>
  <div class="box">
    <h1>AAGUID Inspector</h1>
    <p>This page decodes <code>public/blob.jwt</code> found in the project and extracts any AAGUID found inside attestation/authenticator data.</p>
    <button id="run">Show AAGUID</button>
    <div id="out"></div>
    <h3>Raw diagnostics</h3>
    <pre id="diag"></pre>
  </div>

  <script src="cbor.js"></script>
  <script>
    function bytesToHex(u8){ return Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join(''); }
    function hexToUuid(hex){
      if(typeof hex !== 'string') return '';
      const h = hex.replace(/[^0-9a-fA-F]/g,'').toLowerCase();
      if(h.length !== 32) return '';
      return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
    }

    async function fetchBlobJwt(){
      const resp = await fetch('blob.jwt');
      if(!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      // Try to get as text first (compact JWT) otherwise as bytes
      const txt = await resp.text();
      if(txt && txt.split('.').length >= 3){
        return { type: 'compact', text: txt.trim() };
      }
      // fallback to binary
      const arr = new Uint8Array(await resp.arrayBuffer());
      return { type: 'binary', bytes: arr };
    }

    function base64urlToBytes(b64u){
      b64u = b64u.replace(/-/g,'+').replace(/_/g,'/');
      while(b64u.length % 4) b64u += '=';
      const bin = atob(b64u);
      const out = new Uint8Array(bin.length);
      for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i);
      return out;
    }

    // Extract AAGUID from attestedCredentialData per WebAuthn: aaguid is first 16 bytes of attestedCredData
    function extractAaguidFromAuthData(authDataBytes){
      // authData: rpIdHash(32) + flags(1) + signCount(4) + attestedCredData (if present)
      if(!(authDataBytes instanceof Uint8Array)) return null;
      if(authDataBytes.length < 37) return null;
      const flags = authDataBytes[32];
      const attestedPresent = !!(flags & 0x40);
      if(!attestedPresent) return null;
      // attestedCredData starts at offset 37
      if(authDataBytes.length < 37 + 16) return null;
      const aaguid = authDataBytes.slice(37, 37 + 16);
      return aaguid;
    }

    function tryDecodeAttestationObjectBase64(b64){
      try{ const bytes = CBORPlayground.base64ToBytes(b64); const top = CBORPlayground.decodeCbor(bytes); if(top && top.authData) return {authDataHex: CBORPlayground.bytesToHex(top.authData), aaguid: extractAaguidFromAuthData(top.authData)}; }catch(e){}
      return null;
    }

    function uuidStringToBytes(s){
      if(typeof s !== 'string') return null;
      const cleaned = s.replace(/[^0-9a-fA-F]/g,'').toLowerCase();
      if(cleaned.length !== 32) return null;
      const out = new Uint8Array(16);
      for(let i=0;i<16;i++) out[i] = parseInt(cleaned.substr(i*2,2),16);
      return out;
    }

    function findAaguidInObj(obj){
      try{
        if(!obj || typeof obj !== 'object') return null;
        // Direct property
        if(obj.aaguid){ const maybe = obj.aaguid; const b = uuidStringToBytes(maybe); if(b) return b; }
        // Walk arrays
        if(Array.isArray(obj)){
          for(const it of obj){ const r = findAaguidInObj(it); if(r) return r; }
          return null;
        }
        // Walk object properties
        for(const k of Object.keys(obj)){
          const v = obj[k];
          if(typeof v === 'string'){
            // detect UUID-like strings or 32-hex
            const maybe = v.trim();
            const b = uuidStringToBytes(maybe);
            if(b) return b;
            // sometimes aaguid appears as nested JSON string; check if it's a base64-wrapped attestationObject
          }
          if(v && typeof v === 'object'){
            const r = findAaguidInObj(v); if(r) return r;
          }
        }
      }catch(e){}
      return null;
    }

    document.getElementById('run').addEventListener('click', async ()=>{
      const out = document.getElementById('out'); const diag = document.getElementById('diag'); out.innerHTML=''; diag.textContent='';
      try{
        const blob = await fetchBlobJwt();
        diag.textContent = 'Blob type: ' + blob.type + '\n\n';
        let aaguidBytes = null;
        if(blob.type === 'compact'){
          diag.textContent += 'Compact JWT detected. Splitting parts...\n';
          const parts = blob.text.split('.');
          const payload = parts[1] || '';
          try{
            const payloadBytes = base64urlToBytes(payload);
            // First try UTF-8 JSON
            try{
              const txt = new TextDecoder().decode(payloadBytes);
              const parsed = JSON.parse(txt);
              diag.textContent += 'JSON decoded from JWT payload:\n' + JSON.stringify(parsed, null, 2) + '\n';
              // search recursively for aaguid
              const found = findAaguidInObj(parsed);
              if(found) aaguidBytes = found;
            }catch(jsonErr){
              // Not JSON - try CBOR
              try{
                const decoded = CBORPlayground.decodeCbor(payloadBytes);
                diag.textContent += 'CBOR decoded from JWT payload:\n' + CBORPlayground.formatDiagnostic(decoded) + '\n';
                // Try to find attestationObject or authenticatorData inside payload
                if(decoded && typeof decoded === 'object'){
                  if(decoded.attestationObject) {
                    // attestationObject could be base64
                    const res = tryDecodeAttestationObjectBase64(decoded.attestationObject);
                    if(res && res.aaguid) aaguidBytes = res.aaguid;
                  }
                  if(!aaguidBytes && decoded.authenticatorData){
                    if(decoded.authenticatorData instanceof Uint8Array) aaguidBytes = extractAaguidFromAuthData(decoded.authenticatorData);
                  }
                  // also search generically
                  if(!aaguidBytes){ const found = findAaguidInObj(decoded); if(found) aaguidBytes = found; }
                }
              }catch(e){
                diag.textContent += 'JWT payload is not CBOR (or decode failed): ' + e.message + '\n';
              }
            }
          }catch(e){ diag.textContent += 'Failed to decode JWT payload base64url: '+e.message+'\n'; }
        }

        if(!aaguidBytes && blob.type === 'binary'){
          diag.textContent += 'Binary blob â€” try scanning for embedded attestationObject/playload...\n';
          const bytes = blob.bytes;
          // Heuristic: file could be a JWS detached payload text or hex string - try to search for 'attestationObject' ASCII or for CBOR map with 'authData'
          const asText = new TextDecoder().decode(bytes.slice(0,2000));
          if(asText.includes('attestationObject')){
            diag.textContent += 'Found "attestationObject" text nearby; attempt to find base64 after it.\n';
            // crude regex
            const m = asText.match(/attestationObject[^:\n\r]*[:=][\s\"]*([A-Za-z0-9\-_\=]+)/);
            if(m && m[1]){
              const res = tryDecodeAttestationObjectBase64(m[1]); if(res && res.aaguid) aaguidBytes = res.aaguid;
            }
          }
          // As a last resort, scan for CBOR attestationObject structure in the entire bytes by decoding stream and looking for map with 'authData'
          if(!aaguidBytes){
            try{
              const roots = CBORPlayground.decodeCborStream(bytes);
              for(const r of roots){
                if(r && typeof r === 'object'){
                  if(r.attestationObject){ const res = tryDecodeAttestationObjectBase64(r.attestationObject); if(res && res.aaguid){ aaguidBytes = res.aaguid; break; } }
                  if(r.authenticatorData && r.authenticatorData instanceof Uint8Array){ const a = extractAaguidFromAuthData(r.authenticatorData); if(a){ aaguidBytes = a; break; } }
                }
              }
            }catch(e){ diag.textContent += 'CBOR stream decode failed: '+e.message+'\n'; }
          }
        }

        if(!aaguidBytes){
          // Try to treat file as base64 JWS/blob where payload is CBOR; try to find base64 segments separated by dots in text
          const maybe = blob.type === 'binary' ? new TextDecoder().decode(blob.bytes.slice(0,10000)) : blob.text;
          const dotParts = maybe.match(/[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*/);
          if(dotParts){
            const parts = dotParts[0].split('.');
            try{
              const payloadBytes = base64urlToBytes(parts[1]);
              try{ const decoded = CBORPlayground.decodeCbor(payloadBytes); diag.textContent += 'CBOR decoded from extracted payload:\n'+CBORPlayground.formatDiagnostic(decoded)+'\n'; if(decoded && decoded.authenticatorData instanceof Uint8Array){ aaguidBytes = extractAaguidFromAuthData(decoded.authenticatorData);} }catch(e){}
            }catch(e){}
          }
        }

        if(aaguidBytes){
          const hex = bytesToHex(aaguidBytes).toUpperCase();
          out.innerHTML = `<p><b>AAGUID (hex):</b> <code>${hex}</code></p><p><b>AAGUID (UUID):</b> <code>${hexToUuid(hex)}</code></p>`;
          diag.textContent += '\nAAGUID found: ' + hex + '\n';
        } else {
          out.innerHTML = '<p>No AAGUID found in blob.jwt</p>';
          diag.textContent += '\nNo AAGUID found by heuristics.\n';
        }

      }catch(err){
        document.getElementById('diag').textContent += 'ERROR: ' + (err && err.message ? err.message : err);
      }
    });
  </script>
</body>
</html>
