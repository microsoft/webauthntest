<!doctype html>
<html lang="en" data-theme="light">
<head>
    <meta charset="utf-8">
    <title>CBOR Playground</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.14/dist/full.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="styles.css">
</head>
<body class="min-h-screen bg-base-200 text-base-content cbor-page">
    <div class="min-h-screen flex flex-col">
        <header class="navbar bg-primary text-primary-content px-4">
            <div class="navbar-start">
                <h1 class="text-lg font-semibold"><a href="cbor.html" class="title-link">CBOR Playground</a></h1>
            </div>
        </header>

        <div class="credentials-toolbar cbor-nav-toolbar">
            <div class="credentials-toolbar-actions cbor-nav-toolbar-actions" aria-label="Navigation actions">
                <a class="btn btn-ghost btn-sm btn-circle" href="index.html" title="WebAuthn Playground" aria-label="WebAuthn Playground">
                    <span class="material-symbols-outlined" aria-hidden="true">home</span>
                </a>
                <a class="btn btn-ghost btn-sm btn-circle" href="mds.html" title="Authenticator Metadata" aria-label="Authenticator Metadata">
                    <span class="material-symbols-outlined" aria-hidden="true">badge</span>
                </a>
            </div>
        </div>

        <main class="flex-1 p-4">
            <div class="cbor-container">

        <section class="cbor-section">
        <div class="card bg-base-100 shadow-xl border border-base-300">
            <div class="card-body gap-3">
                <div class="flex items-center justify-between gap-3">
                    <h2 class="font-semibold">Decode CBOR to JSON</h2>
                </div>
                <textarea id="cborInput" class="textarea textarea-bordered w-full cbor-mono" placeholder="Example (hex or 0x-prefixed): a26161016162820203"></textarea>
                <div class="flex items-center flex-wrap gap-2">
                    <button id="decodeBtn" class="btn btn-link btn-sm">Decode</button>
                    <button id="clearBtn" class="btn btn-link btn-sm">Clear</button>
                    <label class="btn btn-link btn-sm" for="importCborFile">Import CBOR File</label>
                    <input type="file" id="importCborFile" accept="application/cbor,.cbor" style="display:none;" />
                    <span id="formatInfo" class="text-xs opacity-70" style="display:none;"></span>
                </div>
            </div>
        </div>

        <div id="decodedCard" class="card bg-base-100 shadow-xl border border-base-300" style="display:none;">
            <div class="card-body gap-3">
                <div class="flex items-center justify-between gap-3">
                    <h2 class="font-semibold">Decoded CBOR (JSON)</h2>
                    <div class="flex gap-1">
                        <button id="downloadDecodedJson" class="btn btn-ghost btn-sm btn-square" title="Download decoded JSON"><span class="material-symbols-outlined" aria-hidden="true">file_download</span></button>
                        <button id="copyDecoded" class="btn btn-ghost btn-sm btn-square" title="Copy decoded output"><span class="material-symbols-outlined" aria-hidden="true">content_copy</span></button>
                        <button id="sendDecodedToEncode" class="btn btn-ghost btn-sm btn-square" title="Send to encoder"><span class="material-symbols-outlined" aria-hidden="true">south</span></button>
                    </div>
                </div>
                <pre id="decodedJson" class="mono" aria-label="Decoded output" style="white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere;"></pre>
            </div>
        </div>

        </section>

        <section class="cbor-section">
        <div class="card bg-base-100 shadow-xl border border-base-300">
            <div class="card-body gap-3">
                <div class="flex items-center justify-between gap-3">
                    <h2 class="font-semibold">Encode JSON to CBOR</h2>
                </div>
                <textarea id="jsonInput" class="textarea textarea-bordered w-full cbor-mono" placeholder="JSON example placeholder will load...\n(If you see this line only, JS failed to set multiline placeholder)"></textarea>
                <div class="flex items-center flex-wrap gap-2">
                    <button id="encodeRun" class="btn btn-link btn-sm">Encode</button>
                    <button id="encodeClear" class="btn btn-link btn-sm">Clear</button>
                    <label class="btn btn-link btn-sm" for="importJsonEncode">Import JSON File</label>
                    <input type="file" id="importJsonEncode" accept="application/json,.json" style="display:none;" />
                    <label class="inline-flex items-center gap-2 cursor-pointer select-none">
                        <input type="checkbox" id="canonicalOrder" class="checkbox checkbox-sm" checked>
                        <span class="text-sm">Canonical</span>
                    </label>
                    <span id="encodeInfo" class="text-xs opacity-70"  style="display:none;"></span>
                </div>
            </div>
        </div>

        <div id="encodedCard" class="card bg-base-100 shadow-xl border border-base-300" style="display:none;">
            <div class="card-body gap-3">
                <div class="flex items-center justify-between gap-3">
                    <h2 class="font-semibold">Encoded CBOR (Hex)</h2>
                    <div class="flex gap-1">
                        <button id="downloadEncodedCbor" class="btn btn-ghost btn-sm btn-square" title="Download encoded CBOR (.cbor)"><span class="material-symbols-outlined" aria-hidden="true">file_download</span></button>
                        <button id="copyEncodedHex" class="btn btn-ghost btn-sm btn-square" title="Copy encoded hex"><span class="material-symbols-outlined" aria-hidden="true">content_copy</span></button>
                        <button id="sendEncodedToDecode" class="btn btn-ghost btn-sm btn-square" title="Send to decoder"><span class="material-symbols-outlined" aria-hidden="true">north</span></button>
                    </div>
                </div>
                <pre id="encodedHex" class="mono" aria-label="Encoded CBOR hex output" style="white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere;"></pre>
            </div>
        </div>

        </section>

        <div id="errorArea" class="text-error font-medium mt-4" role="alert"></div>

        <footer class="opacity-80" style="margin-top: 40px; font-size: 12px;">
        </footer>
            </div>
        </main>
    </div>

    <script src="cbor.js"></script>
    <script>
        const inputEl = document.getElementById('cborInput');
        const jsonEl = document.getElementById('decodedJson');
        const errEl = document.getElementById('errorArea');
        const fmtEl = document.getElementById('formatInfo');

        function detectFormat(text){
            const t = text.trim();
            if(!t) return '';
            // Support optional 0x / 0X hex prefix (not previously detected because of the 'x')
            // We only classify as hex if (after removing prefix + whitespace) length is even and non-zero.
            if(/^0x[0-9a-fA-F\s]*$/i.test(t)){
                const body = t.slice(2).split(/\s+/).join('');
                if(body.length && body.length % 2 === 0) return 'hex';
            }
            if(/^[0-9a-fA-F\s]+$/.test(t) && t.split(/\s+/).join('').length % 2 === 0) return 'hex';
            if(/^[A-Za-z0-9+\/\_\-]+=*$/.test(t) && t.length >= 4) return 'base64';
            if(/^\[[-0-9,\s]+\]$/.test(t)) return 'array';
            return 'unknown';
        }

        function toBytes(text){
            const mode = detectFormat(text);
            if(mode === 'hex') return CBORPlayground.hexToBytes(text);
            if(mode === 'base64') return CBORPlayground.base64ToBytes(text);
            if(mode === 'array') {
                const arr = JSON.parse(text);
                if(!Array.isArray(arr)) throw new Error('Not an array');
                return new Uint8Array(arr);
            }
            throw new Error('Unable to determine input format');
        }

        let lastRoots = null; // meta roots cache

        function render(){
            errEl.textContent='';
            jsonEl.textContent='';
            const raw = inputEl.value;
            const decodedCard = document.getElementById('decodedCard');
            if(!raw.trim()) { decodedCard.style.display='none'; return; }
            try {
                const bytes = toBytes(raw);
                const roots = CBORPlayground.decodeCborStreamTreeMeta(bytes);
                lastRoots = roots;
                const options = { nestedOffsets: false };
                jsonEl.textContent = CBORPlayground.formatMetaRoots(roots, options);
                decodedCard.style.display = jsonEl.textContent.trim()? 'block':'none';
            } catch(e){
                decodedCard.style.display='none';
                errEl.textContent = e.message;
            }
        }

        document.getElementById('decodeBtn').addEventListener('click', render);
        document.getElementById('clearBtn').addEventListener('click', ()=>{ inputEl.value=''; render(); });
        inputEl.addEventListener('input', ()=>{ fmtEl.textContent = detectFormat(inputEl.value) || ''; });

        document.getElementById('downloadDecodedJson').addEventListener('click', ()=>{
            if(!lastRoots){ errEl.textContent='Nothing decoded to download.'; return; }
            try {
                const exported = lastRoots.map(r=> CBORPlayground.exportValue(r.value));
                const jsonOut = JSON.stringify(exported.length===1? exported[0] : exported, null, 2);
                const blob = new Blob([jsonOut], {type:'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'decoded.json'; a.click();
                URL.revokeObjectURL(url);
                decodedJson.style.background='#e0f0ff';
                setTimeout(()=> decodedJson.style.background='', 300);
            } catch(e){ errEl.textContent = e.message; }
        });
        document.getElementById('copyDecoded').addEventListener('click', ()=>{
            if(!decodedJson.textContent.trim()) { errEl.textContent='Nothing to copy.'; return; }
            navigator.clipboard.writeText(decodedJson.textContent).then(()=>{
                errEl.textContent='';
                // brief visual feedback by flashing background
                decodedJson.style.background='#e0ffe8';
                setTimeout(()=> decodedJson.style.background='', 300);
            }).catch(err=>{ errEl.textContent='Copy failed: '+err; });
        });

        document.getElementById('sendDecodedToEncode').addEventListener('click', ()=>{
            const decodedText = (decodedJson && decodedJson.textContent) ? decodedJson.textContent.trim() : '';
            if(!decodedText) { errEl.textContent='Nothing to send.'; return; }
            const jsonInputEl = document.getElementById('jsonInput');
            if(!jsonInputEl) { errEl.textContent='Encode input not found.'; return; }
            jsonInputEl.value = decodedText;
            try { jsonInputEl.focus(); } catch(e) {}
            try { jsonInputEl.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch(e) {}
            // Optional: auto-run encode so the user immediately sees the round-trip result
            try {
                if(typeof encodeJson === 'function') encodeJson(false);
            } catch(e) {
                // Ignore; user can click Encode if auto-run fails
            }
            // brief visual feedback
            jsonInputEl.style.background = '#e0f0ff';
            setTimeout(()=>{ jsonInputEl.style.background = ''; }, 300);
        });
        // Import CBOR file handling
        const importCborFileInput = document.getElementById('importCborFile');
        importCborFileInput.addEventListener('change', (e)=>{
            const file = e.target.files && e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = function(){
                try {
                    const bytes = new Uint8Array(reader.result);
                    // Populate input as uppercase hex for transparency
                    inputEl.value = CBORPlayground.bytesToHex(bytes).toLowerCase();
                    fmtEl.textContent = 'hex';
                    render();
                } catch(err){ errEl.textContent = 'Import error: '+ err.message; }
            };
            reader.onerror = ()=>{ errEl.textContent = 'File read failed.'; };
            reader.readAsArrayBuffer(file);
            // reset so selecting same file again re-triggers
            importCborFileInput.value='';
        });
    inputEl.addEventListener('paste', ()=>{ setTimeout(render, 0); });

    // If caller requested postMessage handshake (?pm=1), participate in handshake.
    // Otherwise if caller passed ?key=... (sessionStorage key) or ?input=... then populate and auto-decode
    (function(){
        try {
            const params = new URLSearchParams(window.location.search);
            const pm = params.get('pm');
            const nonceParam = params.get('nonce');
            if(pm && window.opener){
                // Ask opener for payload: send a 'cbor-ready' message including the nonce.
                try {
                    // Send ready message to opener with nonce (if provided)
                    window.opener.postMessage({ type: 'cbor-ready', nonce: nonceParam || null }, window.location.origin);
                } catch(e) { console.warn('Unable to post cbor-ready to opener', e); }
                // Listen for payload
                function onMsg(ev){
                    try {
                        if(ev.origin !== window.location.origin) return;
                        // allow messages from opener only
                        if(ev.source !== window.opener) return;
                        const d = ev.data || {};
                        // verify nonce matches (if provided) to avoid hijacking
                        if(d && d.type === 'cbor-payload' && typeof d.payload === 'string'){
                            if(nonceParam && d.nonce !== nonceParam){ console.warn('Received cbor-payload with mismatched nonce'); return; }
                            inputEl.value = d.payload;
                            fmtEl.textContent = detectFormat(inputEl.value) || '';
                            // Auto-run decode after short delay to allow UI to settle
                            setTimeout(render, 50);
                            // cleanup
                            try { window.removeEventListener('message', onMsg); } catch(e){}
                        }
                    } catch(e){ console.warn('Error handling incoming cbor-payload', e); }
                }
                window.addEventListener('message', onMsg);
                // If opener doesn't respond, we fall back to key/input handling below when appropriate
            }

            const key = params.get('key');
            if(key) {
                try {
                    const stored = sessionStorage.getItem(key);
                    if(stored) {
                        inputEl.value = stored;
                        // remove stored payload to avoid leaking large data across sessions
                        try { sessionStorage.removeItem(key); } catch(e) { /* ignore */ }
                        fmtEl.textContent = detectFormat(inputEl.value) || '';
                        setTimeout(render, 50);
                        return;
                    }
                } catch(e) {
                    // If sessionStorage read fails, we'll fall back to input param below
                    console.warn('Failed to read sessionStorage key for CBOR payload', e);
                }
            }
            const inp = params.get('input');
            if(inp) {
                // decodeURIComponent was used by index.js, but accept raw too
                try { inputEl.value = decodeURIComponent(inp); } catch(e) { inputEl.value = inp; }
                fmtEl.textContent = detectFormat(inputEl.value) || '';
                // Auto-run decode after short delay to allow UI to settle
                setTimeout(render, 50);
            }
        } catch(e) { /* ignore */ }
    })();

    // ---------------- JSON -> CBOR Encoding Logic ----------------
        const jsonInput = document.getElementById('jsonInput');
        // Set multiline placeholder via JS so \n escapes become actual newlines
    jsonInput.placeholder = `Example JSON / relaxed object:
{
    name: "Alice",
    pubkey: {@bytes:"a1b2"},
    big: {@bigint:"9007199254740993"},
    transactionId: h"001122AABB"
}
Notes: Keys may be unquoted (including negative integers like -1:), h'HEX' or h"HEX" become {@bytes:"HEX"}. Wrappers: {@bytes:".."}, {@bigint:".."}, {@tag:N,value:...}, {@simple:N}.`;
    const encodedHexEl = document.getElementById('encodedHex');
    const encodeInfoEl = document.getElementById('encodeInfo');
    let lastEncodedBytes = null;

    function encodeJson(showErrors=true){
        if(showErrors) errEl.textContent='';
        encodeInfoEl.textContent=''; encodedHexEl.textContent=''; lastEncodedBytes = null;
        const encodedCard = document.getElementById('encodedCard');
        const raw = jsonInput.value.trim();
        if(!raw){ encodedCard.style.display='none'; return; }
        try {
            let parsed;
            try {
                parsed = JSON.parse(raw);
            } catch(primaryErr){
                try {
                    const relaxed = transformRelaxedJson(raw);
                    parsed = JSON.parse(relaxed);
                } catch(relaxedErr){
                    if(showErrors) throw primaryErr; else { encodedCard.style.display='none'; return; }
                }
            }
            const value = CBORPlayground.importValue(parsed);
            const bytes = CBORPlayground.encodeValues([value]);
            lastEncodedBytes = bytes;
            const hex = CBORPlayground.bytesToHex(bytes).toUpperCase();
            encodedHexEl.textContent = hex;
            encodeInfoEl.textContent = bytes.length + ' bytes';
            encodedCard.style.display = hex? 'block':'none';
        } catch(e){
            encodedCard.style.display='none';
            if(showErrors) errEl.textContent = 'Encode error: ' + e.message;
        }
    }

    function transformRelaxedJson(src){
        let s = src; // Do not mutate original externally.
        // Normalize line endings
        s = s.replace(/\r\n?/g,'\n');
        // Remove // comments (not inside strings - heuristic: skip lines with // before quotes balance closes)
        s = s.split('\n').map(line=>{
            const idx = line.indexOf('//');
            if(idx === -1) return line;
            const before = line.slice(0, idx);
            // crude: count quotes; if even number of double quotes before // treat as comment
            const dq = (before.match(/"/g)||[]).length;
            const sq = (before.match(/'/g)||[]).length; // ignore single quotes heuristic
            if(dq % 2 === 0) return before; // remove comment part
            return line; // leave line untouched if inside string
        }).join('\n');
        // Support h'HEX' or h"HEX" or h'hex' forms -> {"@bytes":"HEX"}
        s = s.replace(/h['"]([0-9a-fA-F]+)['"]/g, (_,hex)=> '{"@bytes":"'+hex+'"}');
        // Quote unquoted keys: match start of object member after { or ,
        s = s.replace(/([,{]\s*)([A-Za-z_][A-Za-z0-9_]*)(\s*):/g, '$1"$2"$3:');
        // Replace single quoted strings with double (not perfect; avoids interfering with already double quoted)
        s = s.replace(/'([^'\\]*(?:\\.[^'\\]*)*)'/g, (m,inner)=> '"'+inner.replace(/"/g,'\\"')+'"');
    // Quote bare numeric keys (including negatives like -1:, -42:) so they become valid JSON; encoder later converts numeric-string keys back to numeric CBOR keys
    s = s.replace(/([,{]\s*)(-?[0-9]+)(\s*):/g, '$1"$2"$3:');
        return s;
    }

    document.getElementById('encodeRun').addEventListener('click', ()=> encodeJson(true));
    document.getElementById('encodeClear').addEventListener('click', ()=>{ jsonInput.value=''; encodedHexEl.textContent=''; encodeInfoEl.textContent=''; document.getElementById('encodedCard').style.display='none'; });
    // Import JSON for encoding
    const importJsonEncodeInput = document.getElementById('importJsonEncode');
    importJsonEncodeInput.addEventListener('change', (e)=>{
        const file = e.target.files && e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = function(){
            try {
                jsonInput.value = reader.result;
                encodeJson(false);
            } catch(err){ errEl.textContent = 'Import JSON error: '+ err.message; }
        };
        reader.onerror = ()=>{ errEl.textContent = 'File read failed.'; };
        reader.readAsText(file, 'utf-8');
        importJsonEncodeInput.value='';
    });
    document.getElementById('copyEncodedHex').addEventListener('click', ()=>{
        if(!encodedHexEl.textContent.trim()){ errEl.textContent='Nothing to copy.'; return; }
        navigator.clipboard.writeText(encodedHexEl.textContent).then(()=>{
            errEl.textContent='';
            encodedHexEl.style.background='#e0ffe8';
            setTimeout(()=> encodedHexEl.style.background='', 300);
        }).catch(err=>{ errEl.textContent='Copy failed: '+err; });
    });

    document.getElementById('sendEncodedToDecode').addEventListener('click', ()=>{
        const encodedText = (encodedHexEl && encodedHexEl.textContent) ? encodedHexEl.textContent.trim() : '';
        if(!encodedText) { errEl.textContent='Nothing to send.'; return; }
        inputEl.value = encodedText;
        fmtEl.textContent = detectFormat(inputEl.value) || '';
        try { inputEl.focus(); } catch(e) {}
        try { inputEl.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch(e) {}
        // Auto-run decode so the user immediately sees the round-trip result
        try { render(); } catch(e) {}
        // brief visual feedback
        inputEl.style.background = '#e0f0ff';
        setTimeout(()=>{ inputEl.style.background = ''; }, 300);
    });
    // Download from output card icon
    document.getElementById('downloadEncodedCbor').addEventListener('click', ()=>{
        if(!lastEncodedBytes){ errEl.textContent='Nothing encoded to download.'; return; }
        const blob = new Blob([lastEncodedBytes], {type:'application/cbor'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'data.cbor'; a.click();
        URL.revokeObjectURL(url);
        // visual feedback flash
        encodedHexEl.style.background='#e0f0ff';
        setTimeout(()=> encodedHexEl.style.background='', 300);
    });

    // Toggle canonical ordering
    const canonicalChk = document.getElementById('canonicalOrder');
    canonicalChk.addEventListener('change', ()=>{
        CBORPlayground.canonicalSortMapKeys = canonicalChk.checked;
        // Re-encode immediately if we already have JSON parsed
        if(jsonInput.value.trim()) encodeJson(false);
    });

    // Auto encode on typing with debounce
    let encodeDebounceTimer;
    jsonInput.addEventListener('input', ()=>{
        clearTimeout(encodeDebounceTimer);
        encodeDebounceTimer = setTimeout(()=> encodeJson(false), 300);
    });
    jsonInput.addEventListener('paste', ()=>{ setTimeout(()=> encodeJson(false), 0); });

    </script>
</body>
</html>
